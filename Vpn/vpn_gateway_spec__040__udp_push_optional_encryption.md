# VPN GATEWAY SPEC 040 — UDP PUSH OPTIONAL ENCRYPTION (SURGICAL)

THIS SPEC IS AUTHORITATIVE. DO NOT IMPLEMENT “KEY MANAGEMENT” OR “KEY LOADING” LOGIC. IT ALREADY EXISTS.
IF YOU CANNOT FIND A REQUIRED FUNCTION/TYPE, STOP AND ASK.

ALSO:
- MUST FOLLOW F# camelCase THROUGHOUT ALL F# CODE.
- MUST FOLLOW C# PascalCase THROUGHOUT ALL C# CODE.
- NO COPY/PASTE OF UNVERIFIED CODE. READ THE CURRENT CODEBASE AND APPLY SURGICAL CHANGES ONLY.
- APPSETTINGS.JSON IS FLAT UNDER "appSettings". DO NOT ADD NEW NESTING.

WORKING FOLDER: `C:\GitHub\Softellect\Vpn\`

---

## GOAL

ADD OPTIONAL ENCRYPTION FOR UDP PUSH DATAGRAMS, CONTROLLED BY CONFIG:

- SERVER: PER-CLIENT CONFIG IN `VpnClientData` (FLATTENED APPSETTINGS PER CLIENT GUID).
- CLIENT: FLAT KEYS IN APPSETTINGS (NOT NESTED).

WHEN `useEncryption = true`, UDP PUSH PAYLOAD (AFTER CLIENT ID) MUST BE:
- SIGNED BY SENDER PRIVATE KEY
- ENCRYPTED TO RECIPIENT PUBLIC KEY
- DECRYPTED BY RECIPIENT PRIVATE KEY
- VERIFIED USING SENDER PUBLIC KEY

WHEN `useEncryption = false`, PAYLOAD MUST BE PLAINTEXT (NO CRYPTO CALLS).

CRITICAL CHANGE: **CLIENT ID GUID (16 BYTES) MUST BE UNENCRYPTED AND FIRST IN THE DATAGRAM.**
EVERYTHING AFTER IT IS “PAYLOAD” (EITHER PLAINTEXT OR ENCRYPTED BLOB).

---

## CRYPTO PRIMITIVES (MUST USE EXISTING FUNCTIONS)

USE THESE FUNCTIONS FROM `C:\GitHub\Softellect\Sys\Crypto.fs`:

- `tryEncryptAndSign (e: EncryptionType) data senderPrivateKey recipientPublicKey`
- `tryDecryptAndVerify (e: EncryptionType) encryptedData recipientPrivateKey senderPublicKey`

THEY IMPLEMENT: SIGN(DATA) THEN ENCRYPT(SIGNATURE || DATA), AND REVERSE WITH VERIFY.

DO NOT REIMPLEMENT THESE.

KEY SOURCES ALREADY EXIST:
- PRIVATE KEY HANDLING: `C:\GitHub\Softellect\Vpn\Core\KeyManagement.fs`
- PUBLIC KEY HANDLING: `C:\GitHub\Softellect\Sys\Crypto.fs`
- APPSETTINGS PATHS / KEY FOLDERS ARE LOADED IN: `C:\GitHub\Softellect\Vpn\Core\AppSettings.fs`

DURING `authenticate`, SERVER ALREADY CHECKS/LOADS CLIENT PUBLIC KEY AND STORES IT IN THE SESSION.
CLIENT IS EXPECTED TO HAVE SERVER PUBLIC KEY AVAILABLE (ALREADY IMPLEMENTED).

---

## ERROR POLICY (MUST FOLLOW EXACTLY)

### SERVER SIDE (UDP PUSH)
IF ENCRYPTION EXPECTATION DOES NOT MATCH OR DECRYPT/VERIFY FAILS:
1. LOG **ERROR** ONCE (INCLUDES clientId AND REASON).
2. REMOVE/KICK THE CLIENT SESSION FROM REGISTRY (SO FUTURE PACKETS HAVE NO SESSION).
3. DO NOTHING ELSE FOR THIS CLIENT (NO REPEATED LOGGING; NO SPAM).

### CLIENT SIDE (UDP PUSH)
IF ENCRYPTION EXPECTATION DOES NOT MATCH OR DECRYPT/VERIFY FAILS:
1. LOG **CRITICAL** ONCE.
2. CRASH THE CLIENT PROCESS (FAIL FAST). DO NOT CONTINUE RUNNING.

IMPLEMENT “LOG ONCE” VIA A PER-CLIENT FLAG IN SESSION/STATE, OR BY REMOVING SESSION (SERVER) AND STOPPING PROCESS (CLIENT).

---

## DATAGRAM FORMAT CHANGE (UDP PUSH ONLY)

### NEW FORMAT (FOR ALL PUSH COMMANDS)
```
[0..15]    = clientId GUID bytes (16 bytes, UNENCRYPTED)
[16..end]  = payload bytes (PLAINTEXT OR ENCRYPTED BLOB)
```

THIS APPLIES TO:
- CLIENT → SERVER (DATA, KEEPALIVE, ETC)
- SERVER → CLIENT (DATA, ETC)

### IMPACT
- `C:\GitHub\Softellect\Vpn\Core\UdpProtocol.fs` MUST BE UPDATED:
  - REMOVE/STOP USING CURRENT HEADER STRUCTURE FOR UDP PUSH.
  - CLIENT ID MUST BE FIRST BYTES.
  - THE REST OF THE PAYLOAD MUST BE TREATED AS OPAQUE BYTES.
  - ANY FIELDS PREVIOUSLY IN HEADER (VERSION/FLAGS/ETC) MUST NOT BE SENT UNLESS THEY ARE PART OF THE (OPTIONALLY ENCRYPTED) PAYLOAD.
  - KEEP THE “COMMAND” INFORMATION, BUT IT MUST BE INSIDE THE PAYLOAD (AND THEREFORE ENCRYPTED WHEN useEncryption=true).

YOU MUST UPDATE ALL BUILD/PARSE FUNCTIONS USED BY THE PUSH CLIENT/SERVER LOOPS TO USE THIS NEW SHAPE.

---

## CONFIG CHANGES

### 1) SERVER: VpnClientData
FILE: `C:\GitHub\Softellect\Vpn\Core\AppSettings.fs`

- UPDATE `VpnClientData` RECORD TO INCLUDE:
  - `useEncryption : bool`
  - `encryptionType : EncryptionType`  (SAFE DEFAULT IS EncryptionType.defaultValue)
    - IF `useEncryption=false` THEN encryptionType IS IGNORED.
    - IF `useEncryption=true` THEN encryptionType MUST BE PRESENT AND PARSEABLE, OTHERWISE AUTHENTICATION MUST FAIL FOR THAT CLIENT WITH A CLEAR ERROR.

- UPDATE `VpnClientData.serialize` AND `VpnClientData.tryDeserialize` TO SUPPORT FLAT STRING FORM:

CURRENT SERVER STORES PER CLIENT GUID AS:
`"<client_guid>": "clientName=<client_name>;assignedIp=<client_ip>"`

CHANGE TO:
`"<client_guid>": "clientName=<client_name>;assignedIp=<client_ip>;useEncryption=<true|false>;encryptionType=<value>"`

RULES:
- PARSING MUST BE BACKWARD COMPATIBLE:
  - IF `useEncryption` IS MISSING => DEFAULT `false`
  - IF `encryptionType` IS MISSING => DEFAULT `EncryptionType.defaultValue`
- SERIALIZATION MUST ALWAYS INCLUDE `useEncryption` (AND INCLUDE `encryptionType` WHEN useEncryption=true).

### 2) CLIENT: appsettings.json (FLAT)
FILE: `C:\GitHub\Softellect\Vpn\Core\AppSettings.fs` (LOADING), PLUS CLIENT APPSETTINGS FILE IN DEPLOYMENT

ADD TWO NEW FLAT KEYS UNDER `"appSettings"`:
- `UseEncryption` (bool, default false)
- `EncryptionType` (string, optional; REQUIRED IF UseEncryption=true)

UPDATE `VpnClientAccessInfo` (AND `loadVpnClientAccessInfo`) TO INCLUDE:
- `useEncryption : bool` (default false if missing)
- `encryptionType : EncryptionType option` (default None if missing)

IMPORTANT:
- `loadVpnClientAccessInfo` MUST NOT FAIL IF THESE ARE MISSING.
- IF `useEncryption=true` AND encryptionType IS MISSING/INVALID, CLIENT MUST FAIL FAST EARLY WITH A CLEAR ERROR (CONFIG ERROR).

---

## SESSION DATA REQUIRED

ENSURE PUSH SESSION HAS ACCESS TO:
- `clientId`
- `useEncryption` (from server-side config for this client)
- `encryptionType` (if useEncryption=true)
- `clientPublicKey` (already stored during authenticate; confirm location)
- `serverPrivateKey` (already available via existing key management; DO NOT REIMPLEMENT)
- CLIENT SIDE NEEDS:
  - `clientPrivateKey` (existing)
  - `serverPublicKey` (existing)

IF ANY OF THESE CANNOT BE FOUND IN CURRENT TYPES/STATE, STOP AND ASK.

---

## IMPLEMENTATION TASKS (SURGICAL FILE LIST)

### A) Core protocol update
FILE: `C:\GitHub\Softellect\Vpn\Core\UdpProtocol.fs`

1. DEFINE HELPERS THAT BUILD/PARSE THE NEW DATAGRAM:
   - `buildPushDatagram : VpnClientId -> byte[] -> byte[]`
     - returns `clientIdBytes || payload`
   - `tryParsePushDatagram : byte[] -> Result<VpnClientId * byte[], ErrType>`
     - validates length >= 16
     - returns `(clientId, payloadBytes)`

2. DEFINE HELPERS FOR COMMAND ENCODING INSIDE PAYLOAD:
   - MINIMAL: payload begins with 1 BYTE command, followed by command-specific bytes.
   - DO NOT PUT COMMAND IN THE UNENCRYPTED PREFIX. COMMAND MUST BE INSIDE PAYLOAD, SO IT IS ENCRYPTED WHEN useEncryption=true.

3. UPDATE ALL EXISTING “buildPushX” AND “parsePushX” FUNCTIONS (USED BY CLIENT/SERVER LOOPS) TO USE THE NEW DATAGRAM FORMAT.

### B) Client send path encryption
FILES (LIKELY):
- `C:\GitHub\Softellect\Vpn\Client\...` (WHERE PUSH CLIENT SEND LOOP BUILDS DATAGRAMS)
- AND ANY MODULE THAT BUILDS PUSH MESSAGES

FOR EACH OUTBOUND PUSH MESSAGE:
1. BUILD PLAINTEXT PAYLOAD (INCLUDING COMMAND BYTE + DATA).
2. IF `useEncryption=true`:
   - CALL `tryEncryptAndSign encryptionType payload clientPrivateKey serverPublicKey`
   - IF ERROR => LOG CRITICAL ONCE AND CRASH (FAIL FAST)
   - USE RESULT BYTES AS “payloadBytes”
3. ELSE use payload plaintext as “payloadBytes”
4. BUILD DATAGRAM: `clientIdBytes || payloadBytes`
5. SEND VIA UDP

### C) Server receive path decryption + mismatch policy
FILES (LIKELY):
- COMBINED UDP SERVER RECEIVE LOOP / PROCESSOR (WHERE INBOUND PACKETS ARE DISPATCHED)
- THE FUNCTION THAT CURRENTLY PROCESSES PUSH PACKETS (E.G., `processPushDataPacket`)

FOR EACH INBOUND UDP DATAGRAM:
1. PARSE `(clientId, payloadBytes)` USING NEW PARSER.
2. LOOK UP PUSH SESSION BY clientId.
   - IF NOT FOUND: DROP SILENTLY OR EXISTING BEHAVIOR (NO NEW LOG SPAM).
3. READ SESSION CONFIG: `useEncryption`, `encryptionType`, `clientPublicKey`, AND GET `serverPrivateKey`.
4. IF `useEncryption=true`:
   - CALL `tryDecryptAndVerify encryptionType payloadBytes serverPrivateKey clientPublicKey`
   - IF ERROR:
     - LOG ERROR ONCE
     - REMOVE SESSION FROM REGISTRY
     - RETURN (NO FURTHER PROCESSING)
   - DECRYPTED BYTES ARE PLAINTEXT PAYLOAD
5. IF `useEncryption=false`:
   - TREAT `payloadBytes` AS PLAINTEXT PAYLOAD
   - BUT IF IT “LOOKS ENCRYPTED” YOU STILL MUST NOT TRY TO DECRYPT.
   - IF YOU NEED A MISMATCH CHECK: IMPLEMENT A SIMPLE, RELIABLE CHECK THAT DOES NOT PRODUCE FALSE POSITIVES.
     - IF YOU CANNOT DO THIS RELIABLY WITHOUT NEW FRAMING, DO NOT ADD HEURISTICS.
     - MISMATCH WILL BE CAUGHT FUNCTIONALLY (COMMAND PARSE FAILS) → THEN APPLY KICK POLICY.
6. PARSE PLAINTEXT PAYLOAD INTO COMMAND + DATA AND PROCESS AS BEFORE.

IMPORTANT: “KICK POLICY” MUST TRIGGER ON ANY DECRYPT/VERIFY FAILURE OR ON ANY PAYLOAD PARSE FAILURE WHEN session.useEncryption EXPECTS A DIFFERENT FORMAT. IMPLEMENT THIS SO IT DOES NOT FLOOD LOGS.

### D) Server send path encryption
FILE: WHERE `pushSendLoop` BUILDS DATAGRAMS (SERVER → CLIENT)

FOR EACH PACKET TO SEND TO A GIVEN SESSION:
1. BUILD PLAINTEXT PAYLOAD (COMMAND BYTE + DATA).
2. IF session.useEncryption=true:
   - CALL `tryEncryptAndSign encryptionType payload serverPrivateKey clientPublicKey`
   - IF ERROR:
     - LOG ERROR ONCE
     - REMOVE SESSION FROM REGISTRY
     - STOP SENDING TO THAT CLIENT
3. DATAGRAM = `clientIdBytes || payloadBytes`
4. SEND VIA UDP

### E) Client receive path decryption + crash policy
FILE: PUSH CLIENT RECEIVE LOOP (WHERE UDP DATAGRAMS ARRIVE)

FOR EACH UDP DATAGRAM:
1. PARSE `(clientId, payloadBytes)` AND ENSURE clientId MATCHES THIS CLIENT.
   - IF MISMATCH: LOG CRITICAL ONCE AND CRASH.
2. IF client.useEncryption=true:
   - CALL `tryDecryptAndVerify encryptionType payloadBytes clientPrivateKey serverPublicKey`
   - IF ERROR: LOG CRITICAL ONCE AND CRASH.
   - DECRYPTED BYTES ARE PLAINTEXT PAYLOAD.
3. ELSE treat payloadBytes as plaintext payload.
4. PARSE COMMAND + DATA AND INJECT INTO TUNNEL AS BEFORE.

---

## TEST PLAN (MANUAL)

TEST 1: BOTH SIDES useEncryption=false
- MUST WORK AS BEFORE (PLAINTEXT).
- UDP PUSH MUST STILL FUNCTION.

TEST 2: BOTH SIDES useEncryption=true, SAME encryptionType
- AUTHENTICATE SUCCESS
- PING WORKS
- HTTP/HTTPS WORKS
- NO “Adapter not ready” LOOPING ERRORS.

TEST 3: MISMATCH (CLIENT true, SERVER false)
- CLIENT MUST LOG CRITICAL ONCE AND CRASH (ON FIRST RECEIVE FAILURE OR FIRST SEND FAILURE THAT GETS CONFIRMED).
- SERVER MUST LOG ERROR ONCE AND KICK SESSION.

TEST 4: MISMATCH (CLIENT false, SERVER true)
- SERVER MUST LOG ERROR ONCE AND KICK SESSION.
- CLIENT WILL EXPERIENCE FAILURE; IF IT CAN DETECT IT RELIABLY, CRASH; OTHERWISE IT WILL TIME OUT (ACCEPTABLE IF DETECTION WOULD REQUIRE NEW FRAMING).

---

## IMPORTANT NOTES / NON-GOALS

- DO NOT CHANGE vpnTransportProtocol.
- DO NOT CHANGE KEY GENERATION, KEY FILE LAYOUT, OR KEY LOADING.
- DO NOT ADD NEW SERVICES OR MAJOR REFACTORING.
- DO NOT ADD HEADER FIELDS BACK OUTSIDE THE ENCRYPTED PAYLOAD.
- IF YOU NEED EXTRA FRAMING TO MAKE MISMATCH DETECTION PERFECT, STOP AND ASK. DO NOT INVENT A FORMAT.

---

## QUESTIONS POLICY

IF YOU CANNOT LOCATE ANY OF THESE:
- WHERE SERVER PRIVATE KEY IS RETRIEVED
- WHERE CLIENT PRIVATE KEY IS RETRIEVED
- WHERE SERVER PUBLIC KEY IS LOADED ON CLIENT
- WHERE CLIENT PUBLIC KEY IS STORED IN SESSION ON SERVER
- HOW EncryptionType IS PARSED FROM CONFIG

THEN STOP AND ASK. DO NOT IMPLEMENT A SUBSTITUTE.
